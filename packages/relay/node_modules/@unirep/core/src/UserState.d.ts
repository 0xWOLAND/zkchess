import { ethers } from 'ethers';
import { DB } from 'anondb';
import { Identity } from '@semaphore-protocol/identity';
import { Prover, ReputationProof, EpochKeyProof, SignupProof, UserStateTransitionProof, EpochKeyLiteProof } from '@unirep/circuits';
import { Synchronizer } from './Synchronizer';
/**
 * User state is used for a user to generate proofs and obtain the current user status.
 * It takes user's `ZKIdentity` and checks the events that matches the user's identity.
 */
export default class UserState {
    private _prover;
    private _id;
    private _sync;
    get commitment(): bigint;
    get id(): Identity;
    get sync(): Synchronizer;
    get prover(): Prover;
    constructor(config: {
        synchronizer?: Synchronizer;
        db?: DB;
        attesterId?: bigint | bigint[];
        unirepAddress?: string;
        provider?: ethers.providers.Provider;
        id: Identity;
        prover: Prover;
    });
    start(): Promise<void>;
    waitForSync(n?: number): Promise<void>;
    stop(): void;
    /**
     * Query if the user is signed up in the unirep state.
     * @returns True if user has signed up in unirep contract, false otherwise.
     */
    hasSignedUp(attesterId?: bigint | string): Promise<boolean>;
    /**
     * Query the latest user state transition epoch. If user hasn't performed user state transition,
     * the function will return the epoch which user has signed up in Unirep contract.
     * @returns The latest epoch where user performs user state transition.
     */
    latestTransitionedEpoch(_attesterId?: bigint | string): Promise<number>;
    /**
     * Get the latest global state tree leaf index for an epoch.
     * @param _epoch Get the global state tree leaf index of the given epoch
     * @returns The the latest global state tree leaf index for an epoch.
     */
    latestStateTreeLeafIndex(_epoch?: number, _attesterId?: bigint | string): Promise<number>;
    getEpochKeys(_epoch?: bigint | number, nonce?: number, _attesterId?: bigint | string): bigint | bigint[];
    parseReplData(replData: bigint): {
        data: bigint;
        nonce: bigint;
    };
    /**
     * Get the reputation object from the attester
     * @param toEpoch The latest epoch that the reputation is accumulated
     * @returns The reputation object
     */
    getData: (_toEpoch?: number, _attesterId?: bigint | string) => Promise<bigint[]>;
    getProvableData(attesterId?: bigint | string): Promise<bigint[]>;
    getDataByEpochKey: (epochKey: bigint | string, epoch: number, _attesterId?: bigint | string) => Promise<any[]>;
    /**
     * Check if epoch key nonce is valid
     */
    private _checkEpkNonce;
    private _checkSync;
    getEpochKeyIndex: (epoch: number, _epochKey: bigint | string, _attesterId: bigint | string) => Promise<number>;
    genUserStateTransitionProof: (options?: {
        toEpoch?: number;
        attesterId?: bigint | string;
    }) => Promise<UserStateTransitionProof>;
    /**
     * Generate a reputation proof of current user state and given conditions
     * @param epkNonce The nonce determines the output of the epoch key
     * @param minRep The amount of reputation that user wants to prove. It should satisfy: `posRep - negRep >= minRep`
     * @param maxRep The amount of reputation that user wants to prove. It should satisfy: `negRep - posRep >= maxRep`
     * @param graffiti The graffiti that user wants to prove. It should satisfy: `graffiti == data[SUM_FIELD_COUNT]`
     * @returns The reputation proof of type `ReputationProof`.
     */
    genProveReputationProof: (options: {
        epkNonce?: number;
        minRep?: number;
        maxRep?: number;
        graffiti?: bigint | string;
        proveZeroRep?: boolean;
        revealNonce?: boolean;
        data?: bigint | string;
        attesterId?: bigint | string;
    }) => Promise<ReputationProof>;
    /**
     * Generate a user sign up proof of current user state and the given attester ID
     * @returns The sign up proof of type `SignUpProof`.
     */
    genUserSignUpProof: (options?: {
        epoch?: number;
        attesterId?: bigint | string;
    }) => Promise<SignupProof>;
    genEpochKeyProof: (options?: {
        nonce?: number;
        epoch?: number;
        data?: bigint;
        revealNonce?: boolean;
        attesterId?: bigint | string;
    }) => Promise<EpochKeyProof>;
    genEpochKeyLiteProof: (options?: {
        nonce?: number;
        epoch?: number;
        data?: bigint;
        revealNonce?: boolean;
        attesterId?: bigint | string;
    }) => Promise<EpochKeyLiteProof>;
}
export { UserState };
