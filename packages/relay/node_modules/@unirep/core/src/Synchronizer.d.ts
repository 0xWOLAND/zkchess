/// <reference types="node" />
import { EventEmitter } from 'events';
import { DB, TransactionDB } from 'anondb';
import { ethers } from 'ethers';
import { IncrementalMerkleTree } from '@unirep/utils';
type EventHandlerArgs = {
    event: ethers.Event;
    decodedData: {
        [key: string]: any;
    };
    db: TransactionDB;
};
export declare function toDecString(content: bigint | string | number): string;
/**
 * The synchronizer is used to construct the Unirep state. After events are emitted from the Unirep contract,
 * the synchronizer will verify the events and then save the states.
 */
export declare class Synchronizer extends EventEmitter {
    private _db;
    private _provider;
    private _unirepContract;
    private _attesterId;
    private _settings;
    private _attesterSettings;
    protected defaultStateTreeLeaf: bigint;
    protected defaultEpochTreeLeaf: bigint;
    private _syncAll;
    private _eventHandlers;
    private _eventFilters;
    private pollId;
    pollRate: number;
    blockRate: number;
    private setupComplete;
    private setupPromise;
    private lock;
    /**
     * Maybe we can default the DB argument to an in memory implementation so
     * that downstream packages don't have to worry about it unless they want
     * to persist things?
     **/
    constructor(config: {
        db?: DB;
        attesterId?: bigint | bigint[];
        provider: ethers.providers.Provider;
        unirepAddress: string;
    });
    private buildEventHandlers;
    get db(): DB;
    get provider(): ethers.providers.Provider;
    get unirepContract(): ethers.Contract;
    get settings(): any;
    get attesterId(): bigint;
    get attestersOrClauses(): any[];
    setAttesterId(attesterId: string | bigint): void;
    attesterExist(attesterId: string | bigint): boolean;
    checkAttesterId(attesterId: string | bigint): void;
    setup(): Promise<any>;
    _setup(): Promise<void>;
    private _findStartBlock;
    /**
     * Start polling the blockchain for new events. If we're behind the HEAD
     * block we'll poll many times quickly
     */
    start(): Promise<void>;
    /**
     * Stop synchronizing with Unirep contract.
     */
    stop(): void;
    poll(): Promise<{
        complete: boolean;
    }>;
    private _poll;
    loadNewEvents(fromBlock: number, toBlock: number): Promise<any[]>;
    get contracts(): {
        [x: string]: {
            contract: ethers.Contract;
            eventNames: string[];
        };
    };
    private processEvents;
    /**
     * Wait the synchronizer to process the events until the latest block.
     */
    waitForSync(blockNumber?: number): Promise<void>;
    readCurrentEpoch(attesterId?: bigint | string): Promise<any>;
    calcCurrentEpoch(attesterId?: bigint | string): number;
    calcEpochRemainingTime(attesterId?: bigint | string): number;
    loadCurrentEpoch(attesterId?: bigint | string): Promise<number>;
    epochTreeRoot(epoch: number, attesterId?: bigint | string): Promise<any>;
    epochTreeProof(epoch: number, leafIndex: any, attesterId?: bigint | string): Promise<import("@zk-kit/incremental-merkle-tree").MerkleProof>;
    nullifierExist(nullifier: any): Promise<any>;
    genStateTree(_epoch: number | bigint, attesterId?: bigint | string): Promise<IncrementalMerkleTree>;
    genHistoryTree(_attesterId?: bigint | string): Promise<IncrementalMerkleTree>;
    genEpochTree(_epoch: number | bigint, attesterId?: bigint | string): Promise<IncrementalMerkleTree>;
    /**
     * Check if the global state tree root is stored in the database
     * @param root The queried global state tree root
     * @param epoch The queried epoch of the global state tree
     * @returns True if the global state tree root exists, false otherwise.
     */
    stateTreeRootExists(root: bigint | string, epoch: number, attesterId?: bigint | string): Promise<any>;
    /**
     * Check if the epoch tree root is stored in the database.
     * @param _epochTreeRoot The queried epoch tree root
     * @param epoch The queried epoch of the epoch tree
     * @returns True if the epoch tree root is in the database, false otherwise.
     */
    epochTreeRootExists(_epochTreeRoot: bigint | string, epoch: number): Promise<boolean>;
    /**
     * Get the number of global state tree leaves in a given epoch.
     * @param epoch The epoch query
     * @returns The number of the global state tree leaves
     */
    numStateTreeLeaves(epoch: number, attesterId?: bigint | string): Promise<number>;
    handleStateTreeLeaf({ event, db, decodedData }: EventHandlerArgs): Promise<true | undefined>;
    handleEpochTreeLeaf({ event, db, decodedData }: EventHandlerArgs): Promise<true | undefined>;
    handleUserSignedUp({ decodedData, event, db }: EventHandlerArgs): Promise<true | undefined>;
    handleAttestation({ decodedData, event, db }: EventHandlerArgs): Promise<true | undefined>;
    handleUserStateTransitioned({ decodedData, event, db, }: EventHandlerArgs): Promise<true | undefined>;
    handleEpochEnded({ decodedData, event, db }: EventHandlerArgs): Promise<true | undefined>;
    handleAttesterSignedUp({ decodedData, event, db }: EventHandlerArgs): Promise<true | undefined>;
    handleHistoryTreeLeaf({ decodedData, event, db }: EventHandlerArgs): Promise<true | undefined>;
}
export {};
