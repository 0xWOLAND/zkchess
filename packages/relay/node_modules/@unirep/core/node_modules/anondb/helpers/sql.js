"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.upsertSql = exports.deleteManySql = exports.updateSql = exports.countSql = exports.findManySql = exports.createSql = exports.tableCreationSql = exports.whereToSql = exports.parseType = exports.escapeSingleQuotes = exports.escapeQuotes = void 0;
const types_1 = require("../types");
const escapeQuotes = (str) => {
    if (str === null)
        console.log(new Error().stack);
    return str.replace(/"/gm, '""');
};
exports.escapeQuotes = escapeQuotes;
const escapeSingleQuotes = (str) => str.replace(/'/gm, `''`);
exports.escapeSingleQuotes = escapeSingleQuotes;
function parseType(type, value) {
    if (value === null || value === undefined)
        return 'NULL';
    if (type === 'String' && typeof value === 'string') {
        return `'${(0, exports.escapeSingleQuotes)(value)}'`;
    }
    if (type === 'Int' && typeof value === 'number') {
        return `${value}`;
    }
    if (type === 'Bool' && typeof value === 'boolean') {
        return value ? 'true' : 'false';
    }
    if (type === 'Object' && typeof value === 'object') {
        return `'${(0, exports.escapeSingleQuotes)(JSON.stringify(value))}'`;
    }
    throw new Error(`Unrecognized value "${value}" for type ${type}`);
}
exports.parseType = parseType;
function whereToSql(table, doc = {}, sqlOnly = false) {
    if (Object.keys(doc).length === 0)
        return '';
    const sql = Object.keys(doc)
        .map(key => {
        if (doc[key] === undefined)
            return;
        if (key === 'OR' || key === 'AND')
            return;
        const rowDef = table.rowsByName[key];
        if (!rowDef)
            throw new Error(`Unable to find row definition for key: "${key}"`);
        const val = doc[key];
        if (Array.isArray(val) && val.length === 0) {
            return '(false)';
        }
        if (Array.isArray(val)) {
            const values = val.map(v => parseType(rowDef.type, v));
            return `"${key}" IN (${values.join(',')})`;
        }
        if (typeof val === 'object' && val !== null) {
            const operatorMap = {
                lt: '<',
                gt: '>',
                lte: '<=',
                gte: '>=',
                ne: '!=',
                eq: '=',
            };
            const nullOperatorMap = {
                ne: 'IS NOT',
                eq: 'IS',
            };
            return Object.keys(val).map(k => {
                if (k === 'nin') {
                    if (!Array.isArray(val[k]))
                        throw new Error(`Non array value provided for nin operator`);
                    const values = val[k].map((v) => parseType(rowDef.type, v));
                    return `"${key}" NOT IN (${values.join(',')})`;
                }
                const operator = val[k] === null ? nullOperatorMap[k] : operatorMap[k];
                if (!operator)
                    throw new Error(`Invalid operator ${k}`);
                const parsed = parseType(rowDef.type, val[k]);
                return `"${key}" ${operator} ${parsed}`;
            });
        }
        const parsed = parseType(rowDef.type, val);
        return `"${key}" ${parsed === 'NULL' ? 'IS' : '='} ${parsed}`;
    })
        .flat()
        .filter(i => !!i)
        .join(' AND ');
    let orConditions = 'true';
    if (Array.isArray(doc.OR)) {
        orConditions =
            doc.OR.length > 0
                ? doc.OR.map((w) => whereToSql(table, w, true)).join(' OR ')
                : 'false';
    }
    const andConditions = Array.isArray(doc.AND) && doc.AND.length > 0
        ? doc.AND.map((w) => whereToSql(table, w, true)).join(' AND ')
        : 'true';
    return ` ${sqlOnly ? '' : 'WHERE'} (${sql ||
        'true'}) AND (${orConditions}) AND (${andConditions})`;
}
exports.whereToSql = whereToSql;
function tableCreationSql(tableData) {
    const commands = [];
    for (const table of tableData) {
        const { name, primaryKey, rows } = table;
        const typeMap = {
            String: 'TEXT',
            Int: 'INTEGER',
            Bool: 'BOOLEAN',
            Object: 'TEXT',
        };
        const rowCommands = rows
            .map(row => {
            const fullRow = (0, types_1.normalizeRowDef)(row);
            if (fullRow.relation)
                return;
            return `"${fullRow.name}" ${typeMap[fullRow.type]} ${fullRow.optional ? '' : 'NOT NULL'} ${fullRow.unique ? 'UNIQUE' : ''}`;
        })
            .filter(i => !!i);
        const relationCommands = [];
        if (primaryKey) {
            const primaryKeys = [primaryKey]
                .flat()
                .map((name) => `"${name}"`)
                .join(',');
            relationCommands.push(`PRIMARY KEY (${primaryKeys})`);
        }
        commands.push(`CREATE TABLE IF NOT EXISTS "${name}" (
      ${[rowCommands.join(','), relationCommands.join(',')]
            .filter(i => !!i)
            .join(',')}
    );`);
    }
    return commands.join(' ');
}
exports.tableCreationSql = tableCreationSql;
function createSql(table, _doc) {
    const docs = [_doc].flat();
    for (const [, row] of Object.entries(table.rows)) {
        for (const doc of docs) {
            if (typeof (row === null || row === void 0 ? void 0 : row.default) === 'undefined' ||
                (doc[row.name] !== undefined && doc[row.name] !== null))
                continue;
            Object.assign(doc, {
                [row.name]: typeof row.default === 'function' ? row.default() : row.default,
            });
        }
    }
    const allKeys = [];
    for (const doc of docs) {
        allKeys.push(...Object.keys(doc));
    }
    const keys = [];
    for (const key of allKeys) {
        if (keys.indexOf(key) !== -1)
            continue;
        keys.push(key);
    }
    const uniqueKeys = keys.filter(k => { var _a; return (_a = table.rowsByName[k]) === null || _a === void 0 ? void 0 : _a.unique; });
    const query = [table.primaryKey, uniqueKeys].flat().reduce((acc, key) => {
        if (key === undefined)
            return acc;
        return Object.assign(Object.assign({}, acc), { [key]: [] });
    }, {});
    const keyString = keys.map(k => `"${k}"`).join(',');
    const allValues = [];
    for (const doc of docs) {
        const values = keys
            .map(k => {
            const rowDef = table.rowsByName[k];
            if (!rowDef)
                throw new Error(`Unable to find row definition for key: "${k}"`);
            if (query[k]) {
                query[k].push(doc[k]);
            }
            return parseType(rowDef.type, doc[k]);
        })
            .join(',');
        allValues.push(`(${values})`);
    }
    return {
        sql: `INSERT INTO "${table.name}" (${keyString}) VALUES ${allValues.join(', ')};`,
        query,
    };
}
exports.createSql = createSql;
function findManySql(table, options) {
    const { where } = options;
    const orderBy = options.orderBy && Object.keys(options.orderBy).length > 0
        ? ` ORDER BY ${Object.keys(options.orderBy)
            .filter(key => typeof (options.orderBy || {})[key] === 'string')
            .map(key => {
            const val = (options.orderBy || {})[key];
            return `"${key}" ${val.toUpperCase()}`;
        })
            .join(', ')}`
        : '';
    const limit = options.limit ? ` LIMIT ${options.limit} ` : '';
    return `SELECT * FROM "${table.name}" ${whereToSql(table, where)} ${orderBy} ${limit};`;
}
exports.findManySql = findManySql;
function countSql(table, where) {
    return `SELECT COUNT(*) FROM "${table.name}" ${whereToSql(table, where)};`;
}
exports.countSql = countSql;
function updateSql(table, options) {
    const { where, update } = options;
    const setSql = Object.keys(update)
        .map(key => {
        const rowDef = table.rowsByName[key];
        if (!rowDef)
            throw new Error(`Unable to find row definition for key: "${key}"`);
        return `"${key}" = ${parseType(rowDef.type, update[key])}`;
    })
        .join(', ');
    return `UPDATE "${table.name}" SET ${setSql} ${whereToSql(table, where)};`;
}
exports.updateSql = updateSql;
function deleteManySql(table, options) {
    if (Object.keys(options.where).length === 0)
        return `DELETE FROM "${table.name}";`;
    return `DELETE FROM "${table.name}" ${whereToSql(table, options.where)};`;
}
exports.deleteManySql = deleteManySql;
function upsertSql(table, options) {
    const { sql } = createSql(table, options.create);
    const creationSql = sql.replace(';', '');
    const uniqueFields = [];
    for (const rawRow of table.rows) {
        const row = (0, types_1.normalizeRowDef)(rawRow);
        if ([table.primaryKey].flat().indexOf(row.name) === -1 && !row.unique)
            continue;
        if (typeof options.where[row.name] !== 'undefined')
            uniqueFields.push(row.name);
    }
    const conflictConstraint = [options.constraintKey || uniqueFields]
        .flat()
        .map(name => `"${name}"`)
        .join(',');
    const updateSqlCommand = Object.keys(options.update)
        .map(key => {
        const rowDef = table.rowsByName[key];
        if (!rowDef)
            throw new Error(`Unable to find row definition for key: "${key}"`);
        return `"${key}" = ${parseType(rowDef.type, options.update[key])}`;
    })
        .join(', ');
    const conflictClause = Object.keys(options.update).length === 0
        ? 'DO NOTHING;'
        : `DO UPDATE SET ${updateSqlCommand};`;
    return `${creationSql}
  ON CONFLICT(${conflictConstraint})
  ${conflictClause}`;
}
exports.upsertSql = upsertSql;
//# sourceMappingURL=sql.js.map