"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndexedDBConnector = void 0;
const async_lock_1 = __importDefault(require("async-lock"));
const idb_1 = require("idb");
const types_1 = require("../types");
const memory_1 = require("../helpers/memory");
const shared_1 = require("../helpers/shared");
const callbacks_1 = require("../helpers/callbacks");
class IndexedDBConnector extends types_1.DB {
    constructor(schema) {
        super();
        this.schema = {};
        this.config = {
            name: 'anondb',
            version: 1,
        };
        this.lock = new async_lock_1.default({ maxPending: 100000 });
        this.schema = schema;
    }
    static create(tables, _config = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            const schema = (0, types_1.constructSchema)(tables);
            const connector = new this(schema);
            if (typeof _config === 'number') {
                connector.config.version = _config;
            }
            else if (typeof _config === 'object') {
                Object.assign(connector.config, _config);
            }
            else {
                throw new Error('No config specified');
            }
            connector.db = yield (0, idb_1.openDB)(connector.config.name, connector.config.version, {
                upgrade(db, _, __, tx) {
                    return __awaiter(this, void 0, void 0, function* () {
                        for (const table of tables) {
                            const tableSchema = schema[table.name] || {};
                            const indexes = (schema[table.name] || {}).indexes || [];
                            for (const index of indexes) {
                                const indexRows = index.keys.map(key => tableSchema.rows.find(r => r.name === key));
                                if (indexRows.find(r => r.type === 'Bool')) {
                                    console.log(`WARNING: Boolean indexes in IndexDB will always be empty: index "${index.name}"`);
                                }
                            }
                            if (db.objectStoreNames.contains(table.name)) {
                                for (const index of indexes) {
                                    if (tx.objectStore(table.name).indexNames.contains(index.name)) {
                                        continue;
                                    }
                                    tx.objectStore(table.name).createIndex(index.name, index.keys, {
                                        unique: !!index.unique,
                                    });
                                }
                                for (const indexName of tx.objectStore(table.name).indexNames) {
                                    if (indexes.find(({ name }) => name === indexName)) {
                                        continue;
                                    }
                                    tx.objectStore(table.name).deleteIndex(indexName.toString());
                                }
                            }
                            else {
                                const store = db.createObjectStore(table.name, {
                                    keyPath: table.primaryKey,
                                });
                                for (const index of indexes) {
                                    store.createIndex(index.name, index.keys, {
                                        unique: !!index.unique,
                                    });
                                }
                            }
                        }
                    });
                },
            });
            return connector;
        });
    }
    create(collection, _doc) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => __awaiter(this, void 0, void 0, function* () { return this._create(collection, _doc); }));
        });
    }
    _create(collection, _doc, _tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const table = this.schema[collection];
            if (!table)
                throw new Error(`Invalid collection: "${collection}"`);
            const docs = (0, memory_1.validateDocuments)(table, _doc);
            if (!this.db)
                throw new Error('DB is not initialized');
            const tx = _tx || this.db.transaction(collection, 'readwrite');
            const createPromises = docs.map(doc => {
                const store = tx.objectStore(collection);
                return store.add(doc);
            });
            if (!_tx) {
                yield Promise.all([...createPromises, tx.done]);
            }
            return docs.length === 1 ? docs[0] : docs;
        });
    }
    findOne(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const [obj] = yield this.findMany(collection, Object.assign(Object.assign({}, options), { limit: 1 }));
            return obj === undefined ? null : obj;
        });
    }
    findMany(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('read', () => __awaiter(this, void 0, void 0, function* () { return this._findMany(collection, options); }))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _findMany(collection, options, _tx) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.db)
                throw new Error('DB is not initialized');
            for (const key of Object.keys(options.where)) {
                if (typeof options.where[key] === 'undefined') {
                    delete options.where[key];
                }
            }
            if (Object.keys(options.where).length === 0) {
                return this.findUsingScan(collection, options, _tx);
            }
            for (const key of Object.keys(options.where)) {
                if (key !== 'AND' && key !== 'OR' && !((_a = this.schema[collection]) === null || _a === void 0 ? void 0 : _a.rowsByName[key])) {
                    throw new Error(`Unable to find row definition for key: "${key}"`);
                }
                if (key === 'AND' || key === 'OR')
                    return this.findUsingScan(collection, options, _tx);
                if (options.where[key] === undefined)
                    return this.findUsingScan(collection, options, _tx);
                if (typeof options.where[key] === 'object' &&
                    !Array.isArray(options.where[key])) {
                    return this.findUsingScan(collection, options, _tx);
                }
            }
            const allKeys = [];
            const whereObjects = [options.where, ...(options.where.OR || [])];
            for (const where of whereObjects) {
                allKeys.push(...Object.keys(where));
            }
            const foundKeys = {};
            const keys = allKeys.filter(key => {
                if (key === 'OR')
                    return false;
                if (foundKeys[key])
                    return false;
                foundKeys[key] = true;
                return true;
            });
            const table = this.schema[collection];
            if (!table)
                throw new Error(`Invalid collection: "${collection}"`);
            for (const index of table.indexes || []) {
                let useIndex = true;
                for (const key of keys) {
                    if (index.keys.indexOf(key) === -1) {
                        useIndex = false;
                        break;
                    }
                }
                for (const key of index.keys) {
                    if (keys.indexOf(key) === -1) {
                        useIndex = false;
                        break;
                    }
                }
                if (!useIndex) {
                    continue;
                }
                const tx = _tx || this.db.transaction(collection);
                const txIndex = tx.objectStore(collection).index(index.name);
                const keyVals = {};
                const keyIndexes = {};
                for (const key of Object.keys(options.where)) {
                    keyVals[key] = [options.where[key]].flat().filter(i => i !== undefined);
                    keyIndexes[key] = 0;
                    if (keyVals[key].length === 0) {
                        return [];
                    }
                }
                const resultPromises = [];
                for (;;) {
                    const query = index.keys.map(k => {
                        const val = keyVals[k][keyIndexes[k]];
                        if (typeof val === 'boolean')
                            return val ? 1 : 0;
                        return val;
                    });
                    resultPromises.push(txIndex.getAll(query));
                    let done = true;
                    for (const key of Object.keys(options.where)) {
                        if (keyIndexes[key] < keyVals[key].length - 1) {
                            keyIndexes[key] += 1;
                            done = false;
                            break;
                        }
                    }
                    if (done)
                        break;
                }
                const allResults = (yield Promise.all(resultPromises))
                    .flat()
                    .filter(i => !!i);
                if (options.orderBy && Object.keys(options.orderBy).length > 0) {
                    const key = Object.keys(options.orderBy || {})[0];
                    const order = options.orderBy[key];
                    allResults.sort((a, b) => {
                        if (a[key] > b[key])
                            return 1;
                        if (a[key] < b[key])
                            return -1;
                        return 0;
                    });
                    if (order === 'desc') {
                        allResults.reverse();
                    }
                }
                const finalResults = typeof options.limit === 'number'
                    ? allResults.slice(0, options.limit)
                    : allResults;
                yield (0, shared_1.loadIncluded)(collection, {
                    models: finalResults,
                    include: options.include,
                    findMany: this._findMany.bind(this),
                    table,
                });
                return finalResults;
            }
            return this.findUsingScan(collection, options, _tx);
        });
    }
    findUsingScan(collection, options, _tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const start = +new Date();
            if (!this.db)
                throw new Error('DB is not initialized');
            const table = this.schema[collection];
            if (!table)
                throw new Error(`Invalid collection: "${collection}"`);
            const found = [];
            let cursor;
            const tx = _tx || this.db.transaction(collection);
            if (Object.keys(options.orderBy || {}).length > 0) {
                const key = Object.keys(options.orderBy || {})[0];
                let indexName;
                for (const index of table.indexes || []) {
                    if (index.keys.length === 1 && index.keys[0] === key) {
                        indexName = index.name;
                        break;
                    }
                }
                if (!indexName)
                    throw new Error(`Unable to find index for ordering by ${key}`);
                const direction = (options.orderBy || {})[key] === 'asc' ? 'next' : 'prev';
                const index = tx.objectStore(collection).index(indexName);
                cursor = yield index.openCursor(null, direction);
            }
            else if (Object.keys(options.where).length === 0) {
                cursor = yield tx.objectStore(collection).openCursor();
            }
            else if (options.where.OR !== undefined ||
                options.where.AND !== undefined) {
                cursor = yield tx.objectStore(collection).openCursor();
            }
            else {
                for (const name of tx.objectStore(collection).indexNames) {
                    const index = tx.objectStore(collection).index(name);
                    const keys = [index.keyPath].flat();
                    const ranges = [];
                    for (const key of keys) {
                        const val = options.where[key];
                        if (val === null || val === undefined)
                            break;
                        if (Array.isArray(val))
                            break;
                        const cleanBool = v => {
                            if (typeof v === 'boolean')
                                return v ? 1 : 0;
                            return v;
                        };
                        if (typeof val !== 'object') {
                            ranges.push(IDBKeyRange.only(cleanBool(val)));
                            continue;
                        }
                        if (Object.keys(val).length !== 1)
                            break;
                        if (val.gt !== undefined) {
                            ranges.push(IDBKeyRange.lowerBound(cleanBool(val.gt), true));
                            continue;
                        }
                        else if (val.gte !== undefined) {
                            ranges.push(IDBKeyRange.lowerBound(cleanBool(val.gte), false));
                            continue;
                        }
                        else if (val.lt !== undefined) {
                            ranges.push(IDBKeyRange.upperBound(cleanBool(val.lt), true));
                            continue;
                        }
                        else if (val.lte !== undefined) {
                            ranges.push(IDBKeyRange.upperBound(cleanBool(val.lte), false));
                            continue;
                        }
                        break;
                    }
                    if (ranges.length === keys.length) {
                        cursor = yield index.openCursor(keys.length === 1 ? ranges[0] : ranges);
                        break;
                    }
                }
                if (!cursor) {
                    cursor = yield tx.objectStore(collection).openCursor();
                }
            }
            const { where, limit } = options;
            while (cursor) {
                if (typeof limit === 'number' && found.length >= limit)
                    break;
                const obj = cursor.value;
                if ((0, memory_1.matchDocument)(where, obj)) {
                    found.push(obj);
                }
                cursor = yield cursor.continue();
            }
            yield (0, shared_1.loadIncluded)(collection, {
                models: found,
                include: options.include,
                findMany: this._findMany.bind(this),
                table,
            });
            if (+new Date() - start > 50 && typeof window !== 'undefined')
                console.log('query length scan', collection, where, options.limit, +new Date() - start);
            return found;
        });
    }
    count(collection, where) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Object.keys(where).length !== 0) {
                return (yield this.findMany(collection, { where })).length;
            }
            if (!this.db)
                throw new Error('DB is not initialized');
            const tx = this.db.transaction(collection, 'readonly');
            const store = tx.objectStore(collection);
            return store.count();
        });
    }
    update(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => __awaiter(this, void 0, void 0, function* () { return this._update(collection, options); }))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _update(collection, options, _tx) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.db)
                throw new Error('DB is not initialized');
            const items = yield this._findMany(collection, { where: options.where }, _tx);
            if (Object.keys(options.update).length === 0)
                return items.length;
            const tx = _tx || this.db.transaction(collection, 'readwrite');
            const promises = [];
            const table = this.schema[collection];
            if (!table)
                throw new Error('Table not found');
            for (const item of items) {
                const store = tx.objectStore(collection);
                store.put(Object.assign(Object.assign({}, item), options.update));
            }
            if (!_tx) {
                yield Promise.all([...promises, tx.done]);
            }
            return items.length;
        });
    }
    upsert(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => __awaiter(this, void 0, void 0, function* () { return this._upsert(collection, options); }))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _upsert(collection, options, _tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const updated = yield this._update(collection, options, _tx);
            if (updated > 0) {
                return Object.keys(options.update).length === 0 ? 0 : updated;
            }
            const created = yield this._create(collection, options.create, _tx);
            return Array.isArray(created) ? created.length : 1;
        });
    }
    delete(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => __awaiter(this, void 0, void 0, function* () { return this._delete(collection, options); }))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _delete(collection, options, _tx) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.db)
                throw new Error('DB is not initialized');
            const items = yield this._findMany(collection, { where: options.where }, _tx);
            const tx = _tx || this.db.transaction(collection, 'readwrite');
            const promises = [];
            const table = this.schema[collection];
            if (!table)
                throw new Error('Table not found');
            const store = tx.objectStore(collection);
            for (const item of items) {
                promises.push(store.delete(Array.isArray(table.primaryKey)
                    ? table.primaryKey.map(k => item[k])
                    : item[table.primaryKey]));
            }
            if (!_tx) {
                yield Promise.all([...promises, tx.done]);
            }
            return items.length;
        });
    }
    transaction(operation, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => __awaiter(this, void 0, void 0, function* () { return this._transaction(operation, cb); }))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _transaction(operation, onComplete) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.db)
                throw new Error('DB is not initialized');
            const stores = [];
            let tx;
            let start;
            let promise = new Promise(rs => {
                start = rs;
            });
            const onCommitCallbacks = [];
            const onErrorCallbacks = [];
            const onCompleteCallbacks = [];
            if (onComplete)
                onCompleteCallbacks.push(onComplete);
            const db = {
                delete: (collection, options) => {
                    stores.push(collection);
                    promise = promise.then(() => this._delete(collection, options, tx));
                },
                create: (collection, docs) => {
                    stores.push(collection);
                    promise = promise.then(() => this._create(collection, docs, tx));
                },
                update: (collection, options) => {
                    stores.push(collection);
                    promise = promise.then(() => this._update(collection, options, tx));
                },
                upsert: (collection, options) => {
                    stores.push(collection);
                    promise = promise.then(() => this._upsert(collection, options, tx));
                },
                onCommit: (cb) => {
                    if (typeof cb !== 'function')
                        throw new Error('Non-function onCommit callback supplied');
                    onCommitCallbacks.push(cb);
                },
                onError: (cb) => {
                    if (typeof cb !== 'function')
                        throw new Error('Non-function onError callback supplied');
                    onErrorCallbacks.push(cb);
                },
                onComplete: (cb) => {
                    if (typeof cb !== 'function')
                        throw new Error('Non-function onComplete callback supplied');
                    onCompleteCallbacks.push(cb);
                },
            };
            yield (0, callbacks_1.execAndCallback)(function () {
                return __awaiter(this, void 0, void 0, function* () {
                    yield Promise.resolve(operation(db));
                    if (!stores.length) {
                        ;
                        start();
                        return;
                    }
                    const storeNames = {};
                    const storesUnique = stores.filter(store => {
                        if (storeNames[store])
                            return false;
                        storeNames[store] = true;
                        return true;
                    });
                    tx = this.db.transaction(storesUnique, 'readwrite');
                    start();
                    yield Promise.all([promise, tx.done]);
                });
            }.bind(this), {
                onError: onErrorCallbacks,
                onSuccess: onCommitCallbacks,
                onComplete: onCompleteCallbacks,
            });
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.db)
                throw new Error('DB is not initialized');
            this.db.close();
        });
    }
    closeAndWipe() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.db)
                throw new Error('DB is not initialized');
            this.db.close();
            yield (0, idb_1.deleteDB)(this.config.name, {
                blocked: () => {
                    throw new Error('Database wipe was blocked');
                }
            });
        });
    }
}
exports.IndexedDBConnector = IndexedDBConnector;
//# sourceMappingURL=indexed-db.js.map