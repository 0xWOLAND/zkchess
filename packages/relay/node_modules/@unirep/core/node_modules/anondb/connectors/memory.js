"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryConnector = void 0;
const async_lock_1 = __importDefault(require("async-lock"));
const types_1 = require("../types");
const memory_1 = require("../helpers/memory");
const shared_1 = require("../helpers/shared");
const callbacks_1 = require("../helpers/callbacks");
class MemoryConnector extends types_1.DB {
    constructor(schema) {
        super();
        this.schema = {};
        this.lock = new async_lock_1.default({ maxPending: 100000 });
        this.db = {
            __uniques__: {}
        };
        this.schema = schema;
        for (const key of Object.keys(schema)) {
            this.db[key] = [];
            for (const row of this.uniqueRows(key)) {
                this.db.__uniques__[this.uniqueRowKey(key, row.name)] = {};
            }
        }
    }
    uniqueRowKey(collection, row) {
        return `unique-${collection}-${row}`;
    }
    uniqueRows(_collection) {
        const collection = this.schema[_collection];
        if (!collection) {
            throw new Error(`Invalid collection: "${_collection}"`);
        }
        const rows = [];
        for (const row of collection.rows) {
            if (row.unique || [collection.primaryKey].flat().indexOf(row.name) !== -1)
                rows.push(row);
        }
        return rows;
    }
    checkForInvalidRows(_collection, doc, checkingWhere = false) {
        const collection = this.schema[_collection];
        if (!collection) {
            throw new Error(`Invalid collection: "${_collection}"`);
        }
        for (const d of [doc].flat()) {
            for (const key of Object.keys(d)) {
                if (!collection.rowsByName[key] && key !== 'OR' && key !== 'AND') {
                    throw new Error(`Unable to find row definition for key: "${key}"`);
                }
                else if (!collection.rowsByName[key] && !checkingWhere) {
                    throw new Error(`Unable to find row definition for key: "${key}"`);
                }
            }
        }
    }
    create(collection, doc) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => __awaiter(this, void 0, void 0, function* () { return this._create(collection, doc); }));
        });
    }
    _create(_collection, doc) {
        return __awaiter(this, void 0, void 0, function* () {
            const collection = this.schema[_collection];
            if (!collection) {
                throw new Error(`Invalid collection: "${_collection}"`);
            }
            this.checkForInvalidRows(_collection, doc);
            const docs = (0, memory_1.validateDocuments)(collection, doc);
            const newUniques = {};
            for (const row of this.uniqueRows(_collection)) {
                newUniques[this.uniqueRowKey(_collection, row.name)] = {};
            }
            for (const d of docs) {
                for (const row of this.uniqueRows(_collection)) {
                    if (newUniques[this.uniqueRowKey(_collection, row.name)][d[row.name]] ||
                        this.db.__uniques__[this.uniqueRowKey(_collection, row.name)][d[row.name]]) {
                        throw new Error(`Uniqueness constraint violation for row "${row.name}"`);
                    }
                    newUniques[this.uniqueRowKey(_collection, row.name)][d[row.name]] = true;
                }
            }
            for (const d of docs) {
                this.db[_collection].push(d);
            }
            for (const key of Object.keys(newUniques)) {
                this.db.__uniques__[key] = Object.assign(Object.assign({}, this.db.__uniques__[key]), newUniques[key]);
            }
            if (docs.length === 1) {
                return docs[0];
            }
            else {
                return docs;
            }
        });
    }
    findMany(_collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const collection = this.schema[_collection];
            if (!collection) {
                throw new Error(`Invalid collection: "${_collection}"`);
            }
            this.checkForInvalidRows(_collection, options.where, true);
            const matches = [];
            for (const doc of this.db[_collection]) {
                if ((0, memory_1.matchDocument)(options.where, doc)) {
                    matches.push(Object.assign({}, doc));
                }
            }
            const sortKeys = Object.keys(options.orderBy || {});
            if (sortKeys.length > 0) {
                const sortKey = sortKeys[0];
                matches.sort((a, b) => {
                    if (a[sortKey] > b[sortKey]) {
                        return (options.orderBy || {})[sortKey] === 'asc' ? 1 : -1;
                    }
                    else if (a[sortKey] < b[sortKey]) {
                        return (options.orderBy || {})[sortKey] === 'asc' ? -1 : 1;
                    }
                    return 0;
                });
            }
            yield (0, shared_1.loadIncluded)(_collection, {
                models: matches,
                include: options.include,
                findMany: this.findMany.bind(this),
                table: collection
            });
            return matches;
        });
    }
    findOne(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const docs = yield this.findMany(collection, options);
            if (docs.length > 0) {
                return docs[0];
            }
            return null;
        });
    }
    count(collection, where) {
        return __awaiter(this, void 0, void 0, function* () {
            const docs = yield this.findMany(collection, { where });
            return docs.length;
        });
    }
    update(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => __awaiter(this, void 0, void 0, function* () { return this._update(collection, options); }))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _update(_collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const collection = this.schema[_collection];
            if (!collection) {
                throw new Error(`Invalid collection: "${_collection}"`);
            }
            let updatedCount = 0;
            const newDocs = [];
            this.checkForInvalidRows(_collection, options.update);
            const newUniques = {};
            for (const row of this.uniqueRows(_collection)) {
                newUniques[this.uniqueRowKey(_collection, row.name)] = Object.assign({}, this.db.__uniques__[this.uniqueRowKey(_collection, row.name)]);
            }
            for (const doc of this.db[_collection]) {
                if ((0, memory_1.matchDocument)(options.where, doc)) {
                    updatedCount++;
                    const newDoc = Object.assign(Object.assign({}, doc), options.update);
                    for (const row of this.uniqueRows(_collection)) {
                        delete newUniques[this.uniqueRowKey(_collection, row.name)][doc[row.name]];
                    }
                    for (const row of this.uniqueRows(_collection)) {
                        if (newUniques[this.uniqueRowKey(_collection, row.name)][doc[row.name]]) {
                            throw new Error('Unique constraint violation');
                        }
                        newUniques[this.uniqueRowKey(_collection, row.name)][doc[row.name]] = true;
                    }
                    newDocs.push(newDoc);
                }
                else {
                    newDocs.push(doc);
                }
            }
            this.db[_collection] = newDocs;
            for (const key of Object.keys(newUniques)) {
                this.db.__uniques__[key] = newUniques[key];
            }
            return updatedCount;
        });
    }
    upsert(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => this._upsert(collection, options))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _upsert(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const updatedCount = yield this._update(collection, options);
            if (updatedCount > 0) {
                return Object.keys(options.update).length === 0 ? 0 : updatedCount;
            }
            const created = yield this._create(collection, options.create);
            return Array.isArray(created) ? created.length : 1;
        });
    }
    delete(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => this._delete(collection, options))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _delete(_collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const collection = this.schema[_collection];
            if (!collection) {
                throw new Error(`Invalid collection: "${_collection}"`);
            }
            this.checkForInvalidRows(_collection, options.where);
            const newUniques = {};
            for (const row of this.uniqueRows(_collection)) {
                newUniques[this.uniqueRowKey(_collection, row.name)] = Object.assign({}, this.db.__uniques__[this.uniqueRowKey(_collection, row.name)]);
            }
            const newDocs = [];
            for (const doc of this.db[_collection]) {
                if (!(0, memory_1.matchDocument)(options.where, doc)) {
                    newDocs.push(doc);
                }
                else {
                    for (const row of this.uniqueRows(_collection)) {
                        delete newUniques[this.uniqueRowKey(_collection, row.name)][doc[row.name]];
                    }
                }
            }
            const deletedCount = this.db[_collection].length - newDocs.length;
            this.db[_collection] = newDocs;
            for (const key of Object.keys(newUniques)) {
                this.db.__uniques__[key] = newUniques[key];
            }
            return deletedCount;
        });
    }
    transaction(operation, onComplete) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => this._transaction(operation, onComplete))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _transaction(operation, onComplete) {
        return __awaiter(this, void 0, void 0, function* () {
            const onCommitCallbacks = [];
            const onErrorCallbacks = [];
            const onCompleteCallbacks = [];
            if (onComplete)
                onCompleteCallbacks.push(onComplete);
            let start;
            let promise = new Promise(rs => {
                start = rs;
            });
            const tempDB = {
                __uniques__: Object.assign({}, this.db.__uniques__),
                __mark__: 'test'
            };
            for (const key of Object.keys(this.db)) {
                if (key === '__uniques__')
                    continue;
                tempDB[key] = [];
                for (const doc of this.db[key]) {
                    tempDB[key].push(Object.assign({}, doc));
                }
            }
            const txThis = {
                schema: this.schema,
                db: tempDB
            };
            txThis._delete = this._delete.bind(txThis);
            txThis._create = this._create.bind(txThis);
            txThis._update = this._update.bind(txThis);
            txThis._upsert = this._upsert.bind(txThis);
            txThis.findOne = this.findOne.bind(txThis);
            txThis.findMany = this.findMany.bind(txThis);
            txThis.uniqueRows = this.uniqueRows.bind(txThis);
            txThis.uniqueRowKey = this.uniqueRowKey.bind(txThis);
            txThis.checkForInvalidRows = this.checkForInvalidRows.bind(txThis);
            const db = {
                delete: (collection, options) => {
                    promise = promise.then(() => txThis._delete(collection, options));
                },
                create: (collection, docs) => {
                    promise = promise.then(() => txThis._create(collection, docs));
                },
                update: (collection, options) => {
                    promise = promise.then(() => txThis._update(collection, options));
                },
                upsert: (collection, options) => {
                    promise = promise.then(() => txThis._upsert(collection, options));
                },
                onCommit: (cb) => {
                    if (typeof cb !== 'function')
                        throw new Error('Non-function onCommit callback supplied');
                    onCommitCallbacks.push(cb);
                },
                onError: (cb) => {
                    if (typeof cb !== 'function')
                        throw new Error('Non-function onError callback supplied');
                    onErrorCallbacks.push(cb);
                },
                onComplete: (cb) => {
                    if (typeof cb !== 'function')
                        throw new Error('Non-function onComplete callback supplied');
                    onCompleteCallbacks.push(cb);
                },
            };
            yield (0, callbacks_1.execAndCallback)(function () {
                return __awaiter(this, void 0, void 0, function* () {
                    yield Promise.resolve(operation(db));
                    start();
                    yield promise;
                    this.db = tempDB;
                });
            }.bind(this), {
                onError: onErrorCallbacks,
                onSuccess: onCommitCallbacks,
                onComplete: onCompleteCallbacks,
            });
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    closeAndWipe() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const key of Object.keys(this.db)) {
                this.db[key] = [];
            }
        });
    }
}
exports.MemoryConnector = MemoryConnector;
//# sourceMappingURL=memory.js.map