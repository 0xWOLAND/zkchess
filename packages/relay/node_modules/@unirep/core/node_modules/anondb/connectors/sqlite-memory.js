"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SQLiteMemoryConnector = void 0;
const sql_js_1 = __importDefault(require("sql.js"));
const async_lock_1 = __importDefault(require("async-lock"));
const types_1 = require("../types");
const sql_1 = require("../helpers/sql");
const shared_1 = require("../helpers/shared");
const callbacks_1 = require("../helpers/callbacks");
class SQLiteMemoryConnector extends types_1.DB {
    constructor() {
        super();
        this.schema = {};
        this.lock = new async_lock_1.default({ maxPending: 100000 });
        this.db = {};
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const SQL = yield (0, sql_js_1.default)({});
            this.db = new SQL.Database();
        });
    }
    static create(tables) {
        return __awaiter(this, void 0, void 0, function* () {
            const connector = new this();
            yield connector.init();
            yield connector.createTables(tables);
            return connector;
        });
    }
    create(collection, _doc) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => __awaiter(this, void 0, void 0, function* () { return this._create(collection, _doc); }))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _create(collection, _doc) {
        return __awaiter(this, void 0, void 0, function* () {
            const table = this.schema[collection];
            if (!table)
                throw new Error(`Unable to find table ${collection} in schema`);
            const docs = [_doc].flat();
            if (docs.length === 0)
                return [];
            const { sql, query } = (0, sql_1.createSql)(table, docs);
            yield this.db.exec(sql);
            if (Array.isArray(_doc)) {
                return this._findMany(collection, {
                    where: query,
                });
            }
            return this._findOne(collection, {
                where: query,
            });
        });
    }
    findOne(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('read', () => __awaiter(this, void 0, void 0, function* () { return this._findOne(collection, options); }))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _findOne(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const [obj] = yield this._findMany(collection, Object.assign(Object.assign({}, options), { limit: 1 }));
            return obj === undefined ? null : obj;
        });
    }
    findMany(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('read', () => __awaiter(this, void 0, void 0, function* () { return this._findMany(collection, options); }))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _findMany(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const table = this.schema[collection];
            if (!table)
                throw new Error(`Unable to find table ${collection}`);
            const sql = (0, sql_1.findManySql)(table, options);
            const result = yield this.db.exec(sql);
            if (result.length === 0)
                return [];
            const [{ columns, values }] = result;
            const models = [];
            for (const value of values) {
                const obj = {};
                for (const [index, column] of Object.entries(columns)) {
                    obj[column] = value[index];
                }
                models.push(obj);
            }
            const objectKeys = Object.keys(table.rowsByName).filter(key => {
                var _a;
                return ((_a = table.rowsByName[key]) === null || _a === void 0 ? void 0 : _a.type) === 'Object';
            });
            if (objectKeys.length > 0) {
                for (const model of models) {
                    for (const key of objectKeys) {
                        if (typeof model[key] !== 'string')
                            continue;
                        Object.assign(model, {
                            [key]: JSON.parse(model[key]),
                        });
                    }
                }
            }
            const { include } = options;
            yield (0, shared_1.loadIncluded)(collection, {
                models,
                include,
                findMany: this._findMany.bind(this),
                table,
            });
            return models;
        });
    }
    count(collection, where) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('read', () => __awaiter(this, void 0, void 0, function* () { return this._count(collection, where); }))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _count(collection, where) {
        return __awaiter(this, void 0, void 0, function* () {
            const table = this.schema[collection];
            if (!table)
                throw new Error(`Unable to find table ${collection}`);
            const sql = (0, sql_1.countSql)(table, where);
            const result = yield this.db.exec(sql);
            return result[0].values[0][0];
        });
    }
    update(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => __awaiter(this, void 0, void 0, function* () { return this._update(collection, options); }))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _update(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { where, update } = options;
            if (Object.keys(update).length === 0)
                return this._count(collection, where);
            const table = this.schema[collection];
            if (!table)
                throw new Error(`Unable to find table ${collection} in schema`);
            const sql = (0, sql_1.updateSql)(table, options);
            yield this.db.exec(sql);
            return this.db.getRowsModified();
        });
    }
    upsert(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => __awaiter(this, void 0, void 0, function* () { return this._upsert(collection, options); }))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _upsert(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const table = this.schema[collection];
            if (!table)
                throw new Error(`Unable to find table ${collection} in schema`);
            const sql = (0, sql_1.upsertSql)(table, options);
            yield this.db.run(sql);
            return this.db.getRowsModified();
        });
    }
    delete(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => __awaiter(this, void 0, void 0, function* () { return this._deleteMany(collection, options); }))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _deleteMany(collection, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const table = this.schema[collection];
            if (!table)
                throw new Error(`Unable to find table "${collection}"`);
            const sql = (0, sql_1.deleteManySql)(table, options);
            yield this.db.run(sql);
            return this.db.getRowsModified();
        });
    }
    transaction(operation, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.lock.acquire('write', () => __awaiter(this, void 0, void 0, function* () { return this._transaction(operation, cb); }))
                .catch(err => {
                throw new Error(`anondb error: ${err}`);
            });
        });
    }
    _transaction(operation, onComplete) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof operation !== 'function')
                throw new Error('Invalid operation');
            const sqlOperations = [];
            const onCommitCallbacks = [];
            const onErrorCallbacks = [];
            const onCompleteCallbacks = [];
            if (onComplete)
                onCompleteCallbacks.push(onComplete);
            const transactionDB = {
                create: (collection, _doc) => {
                    const table = this.schema[collection];
                    if (!table)
                        throw new Error(`Unable to find table ${collection} in schema`);
                    const docs = [_doc].flat();
                    if (docs.length === 0)
                        return;
                    const { sql } = (0, sql_1.createSql)(table, docs);
                    sqlOperations.push(sql);
                },
                update: (collection, options) => {
                    const table = this.schema[collection];
                    if (!table)
                        throw new Error(`Unable to find table ${collection} in schema`);
                    if (Object.keys(options.update).length === 0)
                        return;
                    sqlOperations.push((0, sql_1.updateSql)(table, options));
                },
                delete: (collection, options) => {
                    const table = this.schema[collection];
                    if (!table)
                        throw new Error(`Unable to find table "${collection}"`);
                    const sql = (0, sql_1.deleteManySql)(table, options);
                    sqlOperations.push(sql);
                },
                upsert: (collection, options) => {
                    const table = this.schema[collection];
                    if (!table)
                        throw new Error(`Unable to find table "${collection}"`);
                    const sql = (0, sql_1.upsertSql)(table, options);
                    sqlOperations.push(sql);
                },
                onCommit: (cb) => {
                    if (typeof cb !== 'function')
                        throw new Error('Non-function onCommit callback supplied');
                    onCommitCallbacks.push(cb);
                },
                onError: (cb) => {
                    if (typeof cb !== 'function')
                        throw new Error('Non-function onError callback supplied');
                    onErrorCallbacks.push(cb);
                },
                onComplete: (cb) => {
                    if (typeof cb !== 'function')
                        throw new Error('Non-function onComplete callback supplied');
                    onCompleteCallbacks.push(cb);
                },
            };
            yield (0, callbacks_1.execAndCallback)(function () {
                return __awaiter(this, void 0, void 0, function* () {
                    yield Promise.resolve(operation(transactionDB));
                    try {
                        const transactionSql = `BEGIN TRANSACTION;
        ${sqlOperations.join('\n')}
        COMMIT;`;
                        yield this.db.exec(transactionSql);
                    }
                    catch (err) {
                        yield this.db.exec('ROLLBACK;');
                        throw err;
                    }
                });
            }.bind(this), {
                onSuccess: onCommitCallbacks,
                onError: onErrorCallbacks,
                onComplete: onCompleteCallbacks,
            });
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.db.close();
        });
    }
    closeAndWipe() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.transaction(db => {
                for (const [table,] of Object.entries(this.schema)) {
                    db.delete(table, { where: {} });
                }
            });
            yield this.close();
        });
    }
    createTables(tableData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.schema = (0, types_1.constructSchema)(tableData);
            const createTablesCommand = (0, sql_1.tableCreationSql)(tableData);
            yield this.db.exec(createTablesCommand);
        });
    }
}
exports.SQLiteMemoryConnector = SQLiteMemoryConnector;
//# sourceMappingURL=sqlite-memory.js.map