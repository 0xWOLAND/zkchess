"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.constructSchema = exports.normalizeRowDef = exports.DB = void 0;
class DB {
}
exports.DB = DB;
function normalizeRowDef(row) {
    if (Array.isArray(row)) {
        const [name, type, options] = row;
        return Object.assign({ name,
            type }, (options || {}));
    }
    return row;
}
exports.normalizeRowDef = normalizeRowDef;
function constructSchema(tables) {
    const schema = {};
    for (const table of tables) {
        schema[table.name] = Object.assign({ relations: {}, rowsByName: {} }, table);
        const indexes = (table.indexes || []).map(index => (Object.assign(Object.assign({}, index), { name: index.name ? index.name : `${index.keys.join('-')}-index` })));
        for (const row of table.rows) {
            const fullRow = normalizeRowDef(row);
            schema[table.name].rowsByName[fullRow.name] = fullRow;
            schema[table.name].rows = schema[table.name].rows.map(normalizeRowDef);
            if (fullRow.relation) {
                schema[table.name].relations[fullRow.name] = Object.assign({ name: fullRow.name }, fullRow.relation);
            }
            if (fullRow.type !== 'Bool' &&
                (fullRow.optional ||
                    fullRow.unique ||
                    fullRow.index ||
                    [table.primaryKey].flat().indexOf(fullRow.name) !== -1)) {
                indexes.push({
                    name: `${fullRow.name}-auto-index`,
                    keys: [fullRow.name],
                    unique: fullRow.unique,
                    optional: fullRow.optional,
                });
            }
        }
        schema[table.name].indexes = indexes;
    }
    return schema;
}
exports.constructSchema = constructSchema;
//# sourceMappingURL=types.js.map